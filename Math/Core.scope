namespace Math;

/%
@asm

Returns the square root of @"x".
Uses the `sqrtsd` assembly instruction.
%/
func dec sqrt(dec x) {
	dec o = 0.0;
	assembly {
		vlist_get rdi, $x$
		movq xmm0, rdi
		sqrtsd xmm0, xmm0
		movq rdi, xmm0
		vlist_set $o$
	}
	ret o;
}

/%
@complexity: O(log(@"exponent"))

Computes the power of @"base" (decimal) to @"exponent" (integer).

This function uses the divide-and-conquer algorithm.
%/
func dec powInt(dec base, int exponent) { 
	// Special cases
	
	if (exponent == 0) {
		ret 1.0;
	}
	
	if (exponent == 1) {
		ret base;
	}
	
	if (exponent == 2) {
		ret base * base;
	}
	
	if (base == 1.0) {
		ret 1.0;
	}
	
	// Divide and conquer!
	
	// This is basically just an optimized 
	// version of the naive "repeated multiplication"
	
	dec i = powInt(base, exponent / 2);
	if (exponent % 2 == 0) {
		ret i * i;
	} else {
		if (exponent > 0) { // If positive
			ret i * i * base;
		} else { // If negative
			ret i * i / base;
		}
	}
}

/%
Computes the log (base 10) of @"x".

This function uses the Taylor series for log.
%/
func dec log10(dec x) {
	// Special cases
	
	if (x < 0.0) {
		// TODO: prevent x < 0.0
		ret nan;
	}
	
	if (x == 0.0) {
		ret -infinity;
	}
	
	if (x == 1.0) {
		ret 0.0;
	}

	if (x == 10.0) {
		ret 1.0;
	}
	
	if (x == infinity) {
		ret infinity;
	}
	
	// The Taylor series below only works between 0 and 1
	// Transform x to fit in the range with a summand (b)
	// log10(x : 0..inf) = log10(x : 0..=1) + b
	
	// Get "b"
	
	dec b = 0.0;
	while (x >= 1.0) {
		x /= 10.0;
		b += 1.0;
	}
	
	// sqrt(1/10) = 0.316227766016837
	while(x <= 0.316227766016837) {
		x *= 10.0;
		b -= 1.0;
	}
	
	// Taylor series (for seriesSum)
	
	dec z = (x - 1.0) / (x + 1.0);
	
	// ln(z) = 2 * (z + (z^3 / 3) + (z^5 / 5) + ...)
	dec seriesSum = z;
	for (int k : 3..23 step 2) {
		seriesSum += powInt(z, k) / k -> dec;
	}
	seriesSum *= 2.0;
	
	// Finally, return
	// log10(x) = ln(x) * log10(e) + b
	
	// log10(e) = 0.434294481903251
	ret seriesSum * 0.434294481903251 + b;
}

/%
Computes the natural log (log base e) of @"x".

This function uses @"log10" to compute the natural log.
%/
func dec ln(dec x) {
	// ln(x) = log10(x) / log10(e)
	ret log10(x) / 0.434294481903251;
}

/%
Computes the log of @"x" with an arbitrary base, @"base".

Use @"log10" for a base of `10`.
Use @"ln" for a base of `e`.

This function uses two calls to @"log10" to compute the result.
%/
func dec log(dec x, dec base) {
	if (base <= 0.0) {
		// TODO: prevent x <= 0.0
		ret nan;
	}

	// log_base(x) = log10(x) / log10(base)
	ret log10(x) / log10(base);
}